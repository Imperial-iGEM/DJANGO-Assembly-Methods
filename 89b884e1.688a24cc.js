(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{71:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return s}));var a=n(2),l=n(6),i=(n(0),n(93)),o={sidebar_label:"sbol_parser_api.sbolParserApi",title:"sbol_parser_api.sbolParserApi"},r={unversionedId:"reference/sbol_parser_api/sbolParserApi",id:"reference/sbol_parser_api/sbolParserApi",isDocsHomePage:!1,title:"sbol_parser_api.sbolParserApi",description:"ParserSBOL Objects",source:"@site/docs/reference/sbol_parser_api/sbolParserApi.md",slug:"/reference/sbol_parser_api/sbolParserApi",permalink:"/DJANGO-Assembly-Methods/docs/reference/sbol_parser_api/sbolParserApi",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/sbol_parser_api/sbolParserApi.md",version:"current",sidebar_label:"sbol_parser_api.sbolParserApi"},b=[{value:"ParserSBOL Objects",id:"parsersbol-objects",children:[]}],c={rightToc:b};function s(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"parsersbol-objects"},"ParserSBOL Objects"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"class ParserSBOL()\n")),Object(i.b)("h4",{id:"generate_csv"},"generate","_","csv"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | generate_csv(assembly: str, dictOfParts: Dict[str, Dict[str, Union[str, int, float]]] = None, repeat: bool = False, maxWellsFilled: int = 96, numRuns: int = 1) -> Dict[str, List[str]]\n")),Object(i.b)("p",null,"Create construct and parts/linkers CSVs for DNABot input"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly(str)")," - Assembly type."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dictOfParts")," ",Object(i.b)("em",{parentName:"li"},"Dict[str, Dict[str, Union","[str, int, float]","]]")," - Dictionary\nof information regarding parts to be assembled.\nStructure:\n{","<","display ID",">",": {","'","concentration","'",":..., ","'","plate","'",":..., ","'","well","'",":...}}"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"repeat")," ",Object(i.b)("em",{parentName:"li"},"bool")," - If False, removes constructs that contain repeated\ncomponents. (default: False)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"maxWellsFilled")," ",Object(i.b)("em",{parentName:"li"},"int")," - Number of wells to be filled in the\nconstructs plate. (default: 96)"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"numRuns")," ",Object(i.b)("em",{parentName:"li"},"int")," - Number of runs (i.e. construct plates) to be\ncreated. (default: 1)")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"Dict[str,List[str]]")," - Dictionary containing lists of paths to csvs\ngenerated.")),Object(i.b)("h4",{id:"getrootcomponentdefinitions"},"getRootComponentDefinitions"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getRootComponentDefinitions(sbolDocument: Document = None) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get the root component definitions of an SBOL document."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sbolDocument")," ",Object(i.b)("em",{parentName:"li"},"Document")," - SBOL document from\nwhich to get root component definitions (default: self.doc)")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of root component definitions.")),Object(i.b)("h4",{id:"getrootcombinatorialderivations"},"getRootCombinatorialDerivations"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getRootCombinatorialDerivations(sbolDocument: Document = None) -> List[CombinatorialDerivation]\n")),Object(i.b)("p",null,"Get the root combinatorial derivations of an SBOL Document."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sbolDocument")," ",Object(i.b)("em",{parentName:"li"},"Document")," - SBOL document from\nwhich to get root combinatorial derivations (default: self.doc)")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of root combinatorial derivations.")),Object(i.b)("h4",{id:"getlistofconstructs"},"getListOfConstructs"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getListOfConstructs(listOfNonCombUris: List[str] = [], listOfCombUris: List[str] = []) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get the list of constructs (component definitions) specified by\nthe list of non-combinatorial URIs and combinatorial derivation URIs.\nExpands combinatorial derivations."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listOfNonCombUris")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of component definition\nURIs pointing to non-combinatorial designs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listOfCombUris")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of combinatorial derivation\nURIs pointing to combinatorial designs.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of component definitions specifying constructs\nto be assembled")),Object(i.b)("h4",{id:"enumerator"},"enumerator"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | enumerator(derivation: CombinatorialDerivation) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get the list of constructs enumerated from a combinatorial derivation.."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"derivation")," ",Object(i.b)("em",{parentName:"li"},"CombinatorialDerivation")," - Combinatorial derivation\nto be enumerated.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of component definitions specifying the\nenumerated constructs.")),Object(i.b)("h4",{id:"addchildren"},"addChildren"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | addChildren(originalTemplate: ComponentDefinition, originalComponent: Component, newParent: ComponentDefinition, children: List[ComponentDefinition])\n")),Object(i.b)("p",null,"Adds children to new parent component definition based on the\noriginal template."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"originalTemplate")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Original template\ndescribing the design of the new parent"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"originalComponent")," ",Object(i.b)("em",{parentName:"li"},"Component")," - Variable component in the\noriginal template to be replaced in new parent"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"newParent")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - New component definition\ndescribing an enumerated design"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"children")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - Children to be added\nto the new parent based on the variants")),Object(i.b)("h4",{id:"removeconstraintreferences"},"removeConstraintReferences"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | removeConstraintReferences(newParent: ComponentDefinition, newComponent: Component)\n")),Object(i.b)("p",null,"Remove sequence constraints of the component in the component definition"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"newParent")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Component definition containing\nthe new component."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"newComponent")," ",Object(i.b)("em",{parentName:"li"},"Component")," - Component to remove sequence\nconstraints from.")),Object(i.b)("h4",{id:"createtemplatecopy"},"createTemplateCopy"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | createTemplateCopy(template: ComponentDefinition, displayId: str, version: str) -> ComponentDefinition\n")),Object(i.b)("p",null,"Create a copy of the template of the combinatorial derivation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"template")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Template of the\ncombinatorial derivation."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"displayId")," ",Object(i.b)("em",{parentName:"li"},"str")," - Display ID to be assigned to the copy."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"version")," ",Object(i.b)("em",{parentName:"li"},"str")," - Version of the copy.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"ComponentDefinition")," - Copy of template.")),Object(i.b)("h4",{id:"getuniquedisplayid"},"getUniqueDisplayId"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getUniqueDisplayId(comp: ComponentDefinition = None, derivation: CombinatorialDerivation = None, displayId: str = None, version: str = None, dataType: str = None, doc: Document = None) -> str\n")),Object(i.b)("p",null,"Creates a unique display ID for an SBOL object."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"comp")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Component definition containing\nthe SBOL object"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"derivation")," ",Object(i.b)("em",{parentName:"li"},"CombinatorialDerivation")," - Combinatorial derivation\ncontaining the SBOL object"),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"displayId")," ",Object(i.b)("em",{parentName:"li"},"str")," - Base display ID for SBOL object."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"version")," ",Object(i.b)("em",{parentName:"li"},"str")," - Version of SBOL object."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dataType")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of SBOL object."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"doc")," ",Object(i.b)("em",{parentName:"li"},"str")," - SBOL Document containing the SBOL object.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"str")," - Unique display ID of SBOL object.")),Object(i.b)("h4",{id:"concatenatechildrendisplayid"},"concatenateChildrenDisplayId"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | concatenateChildrenDisplayId(children: List[ComponentDefinition]) -> str\n")),Object(i.b)("p",null,"Concatenate the names of the variant child components."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"children")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - List of variant\nchild components of an enumerated design (as\ncomponent definition).")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"str")," - Concanated names of variant child components.")),Object(i.b)("h4",{id:"collectvariants"},"collectVariants"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | collectVariants(vc: VariableComponent) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Collect all variants within a variable component\nof a combinatorial derivation."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"vc")," ",Object(i.b)("em",{parentName:"li"},"VariableComponent")," - Variable component of a\ncombinatorial derivation.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[ComponentDefinition]")," - List of variants (as\ncomponent definitions) contained within a\nvariable component of a combinatorial derivation.")),Object(i.b)("h4",{id:"group"},"group"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | group(variants: List[ComponentDefinition], repeat: str) -> List[List[ComponentDefinition]]\n")),Object(i.b)("p",null,"Groups variants based on combinatorial strategy."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"variants")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefintiion]")," - List of variants\nin a variable component.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[List[ComponentDefinition]]")," - Groups of variants.")),Object(i.b)("h4",{id:"generatecombinations"},"generateCombinations"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | generateCombinations(groups: List[List[ComponentDefinition]], variants: List[ComponentDefinition], i: int, sets: List[ComponentDefinition])\n")),Object(i.b)("p",null,"Generate all possible subsets in a set of variants."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"groups")," ",Object(i.b)("em",{parentName:"li"},"List[List","[ComponentDefintiion]","]")," - Groups of variants."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"variants")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - List of variants (as\ncomponent definitions)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"i")," ",Object(i.b)("em",{parentName:"li"},"int")," - Iterator."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"sets")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - Sets of variants.")),Object(i.b)("h4",{id:"filterconstructs"},"filterConstructs"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | filterConstructs(allConstructs: List[ComponentDefinition]) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Removes constructs with repeated components."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allConstructs")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - List of constructs\nto filter.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[ComponentDefinition]")," - List of filtered constructs.")),Object(i.b)("h4",{id:"flatten"},"flatten"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | flatten(construct: ComponentDefinition) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Flattens a heirarchical component definition."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"construct")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Component definition to\nflatten.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[ComponentDefinition]")," - Returns a list of component\ndefinitions corresponding to the components contained\nwithin the component definition including all\nnested components.")),Object(i.b)("h4",{id:"displaylistofparts"},"displayListOfParts"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | displayListOfParts() -> List[str]\n")),Object(i.b)("p",null,"Displays list of parts used in the assembly of the constructs\nin the SBOL document used to initialize the parser."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[str]")," - List of display IDs of parts.")),Object(i.b)("h4",{id:"getlistofparts"},"getListOfParts"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getListOfParts(allConstructs: List[ComponentDefinition] = []) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get list of parts (component defintions) from the list of\nall constructs."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allConstructs")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of all constructs to be assembled.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of component definitions specifying parts used across\nall constructs to be assembled.")),Object(i.b)("h4",{id:"getsortedlistofparts"},"getSortedListOfParts"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getSortedListOfParts(listOfParts: List[ComponentDefinition]) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get a sorted list of parts (str) from the list of parts.\nSort by sbol2 displayId"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listOfParts")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of parts to be sorted. (generated\nby getListOfConstructs)")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of sorted parts (str)")),Object(i.b)("h4",{id:"getdictofcomponents"},"getDictOfComponents"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getDictOfComponents(listOfConstructs: List[ComponentDefinition]) -> Dict[str, ComponentDefinition]\n")),Object(i.b)("p",null,"Get a dictionary of components (as component definitions)\nfrom the list of constructs as\n{construct.displayId: construct.components (as component definitions)}"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listOfConstructs")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of constructs")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dict")," - Dictionary of components")),Object(i.b)("h4",{id:"fillplateoplates"},"fillPlateoPlates"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | fillPlateoPlates(allContent: List[ComponentDefinition], contentName: str, numPlate: int = None, plate_class: plateo.Plate = None, maxWellsFilled: int = None, dictOfParts: Dict[str, Dict[str, Union[str, int, float]]] = None) -> List[plateo.Plate]\n")),Object(i.b)("p",null,"Generate a list of plateo plate objects from list of constructs"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allContent")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of constructs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"contentName")," ",Object(i.b)("em",{parentName:"li"},"str")," - Name of content (Construct or Part)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"numPlate")," ",Object(i.b)("em",{parentName:"li"},"int")," - Number of plates to be generated (default = 1).\nplate_class (plateo.Plate):\nClass of plateo plate (default = Plate96)."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"maxWellsFilled")," ",Object(i.b)("em",{parentName:"li"},"int")," - Maximum number of filled wells on a plate.\ndictOfParts (Dict[str, Dict[str, Union","[str, int, float]","]]):\nDictionary of parts and associated information")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of plates")),Object(i.b)("h4",{id:"getallcontentfromplateoplate"},"getAllContentFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getAllContentFromPlateoPlate(contentPlate: plateo.Plate, contentName: str) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get a list of all content (as component definitions) from a\nPlateo plate."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"contentPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Plateo plate containing content."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"contentName")," ",Object(i.b)("em",{parentName:"li"},"str")," - Name of content (Construct or Part).")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"list")," - List of all content (as component definitions).")),Object(i.b)("h4",{id:"getminnumberofbasicparts"},"getMinNumberOfBasicParts"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getMinNumberOfBasicParts(allConstructs: List[ComponentDefinition]) -> int\n")),Object(i.b)("p",null,"Get the minimum number of Part/Linker pairs required to perform\nBASIC assembly for all constructs."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"allConstructs")," ",Object(i.b)("em",{parentName:"li"},"list")," - List of all constructs as component\ndefinitions.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"int")," - Number of Part/Linker paris for BASIC assembly.")),Object(i.b)("h4",{id:"getconstructcsvheader"},"getConstructCsvHeader"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getConstructCsvHeader(minNumberOfBasicParts: int) -> List[str]\n")),Object(i.b)("p",null,"Create header for Construct CSV for DNABot"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"minNumberOfBasicParts")," ",Object(i.b)("em",{parentName:"li"},"int")," - Minimum number of of Part/Linker\npairs required to perform BASIC assembly for all constructs.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[str]")," - List of strings describing header for Construct CSV.")),Object(i.b)("h4",{id:"getwellcomponentdictfromplateoplate"},"getWellComponentDictFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getWellComponentDictFromPlateoPlate(constructPlate: plateo.Plate, assembly: str) -> Dict[str, List[ComponentDefinition]]\n")),Object(i.b)("p",null,"Get a dictionary of wells containing components comprising\nconstructs (as component definitions) in the form\n{Wellname:","[Components]","}"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"constructPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Plateo plate containing constructs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of assembly.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dict")," - Dictionary of wells containing components.")),Object(i.b)("h4",{id:"getlistfromwellcomponentdict"},"getListFromWellComponentDict"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getListFromWellComponentDict(dictWellComponent: Dict[str, ComponentDefinition], assembly: str) -> List[str]\n")),Object(i.b)("p",null,"Get a concatenated list of wellname and components (as display ID)\ncomprising the construct from the dictionary of wells containing\nconstructs."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"dictWellComponent")," - Dictionary of wells containing constructs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of assembly.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[str]")," - List of wellnames and components (as display ID).")),Object(i.b)("h4",{id:"getconstructdffromplateoplate"},"getConstructDfFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getConstructDfFromPlateoPlate(constructPlate: plateo.Plate, assembly: str) -> pd.DataFrame\n")),Object(i.b)("p",null,"Get dataframe of constructs from Plateo plate containing constructs."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"constructPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Plateo plate containing constructs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of assembly.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pd.DataFrame")," - Dataframe of constructs.")),Object(i.b)("h4",{id:"getconstructcsvfromplateoplate"},"getConstructCsvFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getConstructCsvFromPlateoPlate(constructPlate: plateo.Plate, assembly: str)\n")),Object(i.b)("p",null,"Convert construct dataframe into CSV and creates CSV file in the same\ndirectory."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"constructPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Plateo plate containing constructs."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"uniqueId")," ",Object(i.b)("em",{parentName:"li"},"str")," - Unique ID appended to filename."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of assembly.")),Object(i.b)("h4",{id:"islinker"},"isLinker"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | isLinker(part: ComponentDefinition) -> bool\n")),Object(i.b)("p",null,"Check whether a part is a linker."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"part")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Part to check.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"bool")," - True if part is a linker. False otherwise.")),Object(i.b)("h4",{id:"getlinkersp"},"getLinkerSP"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getLinkerSP(linker: ComponentDefinition) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Get linker prefixes and suffixes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"linker")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Linker to get prefix and suffix.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[ComponentDefinition]")," - Linker prefix and suffix (as\ncomponent definitions).")),Object(i.b)("h4",{id:"convertlinkertosuffixprefix"},"convertLinkerToSuffixPrefix"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | convertLinkerToSuffixPrefix(listOfParts: List[ComponentDefinition]) -> List[ComponentDefinition]\n")),Object(i.b)("p",null,"Convert all linkers contained in a list of parts into linker\nprefixes and suffixes."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"listOfParts")," ",Object(i.b)("em",{parentName:"li"},"List","[ComponentDefinition]")," - List of parts\nused in the assembly of all constructs.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[ComponentDefinition]")," - List of parts with linkers\nconverted into linker prefixes and suffixes.")),Object(i.b)("h4",{id:"getwellcontentdictfromplateoplate"},"getWellContentDictFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getWellContentDictFromPlateoPlate(plateoPlate: plateo.Plate, contentName: str) -> Dict[str, Tuple[ComponentDefinition, float]]\n")),Object(i.b)("p",null,"Get the contents of a well based on well data."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"plateoPlate")," ",Object(i.b)("em",{parentName:"li"},"plate.Plate")," - Plate to get well\ncontent from."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"contentName")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of content in well (",'"',"Construct",'"',"\nor ",'"',"Part).")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("p",null,"  Dict[str, Tuple","[ComponentDefinition, float]","]: Dictionary\nof well content with wellname as keys, and component\ndefinition of the part or construct and concentration\nas values."),Object(i.b)("h4",{id:"getlistfromwellpartdict"},"getListFromWellPartDict"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getListFromWellPartDict(dictWellPart: Dict[str, Tuple[ComponentDefinition, float]]) -> List[str]\n")),Object(i.b)("p",null,"Convert a dictionary of well contents into a list."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("p",null,"  dictWellPart (Dict[str, Tuple","[ComponentDefinition, float]","]):\nDictionary of well contents in a plate."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"List[str]")," - Formatted list of well contents.")),Object(i.b)("h4",{id:"getpartlinkerdffromplateoplate"},"getPartLinkerDfFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getPartLinkerDfFromPlateoPlate(partPlate: plateo.Plate) -> pd.DataFrame\n")),Object(i.b)("p",null,"Get part/linker dataframe from a plate."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"partPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Plate containing parts used for the\nassembly of constructs.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"pd.DataFrame")," - Dataframe of part/linkers and their associated\nwellname and concentration.")),Object(i.b)("h4",{id:"getpartlinkercsvfromplateoplate"},"getPartLinkerCsvFromPlateoPlate"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | getPartLinkerCsvFromPlateoPlate(constructPlate: plateo.Plate, assembly: str, dictOfParts: Dict[str, Dict[str, Union[str, int, float]]] = None)\n")),Object(i.b)("p",null,"Get part/linker CSV from plate."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"constructPlate")," ",Object(i.b)("em",{parentName:"li"},"plateo.Plate")," - Construct plates from which\nparts and linkers are derived."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"assembly")," ",Object(i.b)("em",{parentName:"li"},"str")," - Type of assembly.\ndictOfParts (Dict[str, Dict[str, Union","[str, int, float]","]]):\nDictionary of parts and associated information.")),Object(i.b)("h4",{id:"is_linkers_order_correct"},"is","_","linkers","_","order","_","correct"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | is_linkers_order_correct(construct: ComponentDefinition) -> bool\n")),Object(i.b)("p",null,"Check input construct components has the\norder of -linker-part-linker..."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"construct")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Constructs to check.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"bool")," - True if linker order is correct.")),Object(i.b)("h4",{id:"validatebiobricksconstruct"},"validateBioBricksConstruct"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"})," | validateBioBricksConstruct(construct: ComponentDefinition) -> bool\n")),Object(i.b)("p",null,"Check that biobricks construct has the structure\nplasmid-prefix-suffix."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Arguments"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"construct")," ",Object(i.b)("em",{parentName:"li"},"ComponentDefinition")," - Construct to check.")),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Returns"),":"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"bool")," - True if construct structure is correct.")))}s.isMDXComponent=!0},93:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return O}));var a=n(0),l=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function b(e,t){if(null==e)return{};var n,a,l=function(e,t){if(null==e)return{};var n,a,l={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var c=l.a.createContext({}),s=function(e){var t=l.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return l.a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},u=l.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=b(e,["components","mdxType","originalType","parentName"]),p=s(n),u=a,O=p["".concat(o,".").concat(u)]||p[u]||m[u]||i;return n?l.a.createElement(O,r(r({ref:t},c),{},{components:n})):l.a.createElement(O,r({ref:t},c))}));function O(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var r={};for(var b in t)hasOwnProperty.call(t,b)&&(r[b]=t[b]);r.originalType=e,r.mdxType="string"==typeof e?e:a,o[1]=r;for(var c=2;c<i;c++)o[c]=n[c];return l.a.createElement.apply(null,o)}return l.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);