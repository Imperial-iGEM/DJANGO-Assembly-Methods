(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{72:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return l})),a.d(t,"rightToc",(function(){return s})),a.d(t,"default",(function(){return m}));var n=a(2),r=a(6),o=(a(0),a(93)),i={sidebar_label:"moclo_assembly.moclo_transformation.moclo_transform_generator",title:"moclo_assembly.moclo_transformation.moclo_transform_generator"},l={unversionedId:"reference/moclo_assembly/moclo_transformation/moclo_transform_generator",id:"reference/moclo_assembly/moclo_transformation/moclo_transform_generator",isDocsHomePage:!1,title:"moclo_assembly.moclo_transformation.moclo_transform_generator",description:"moclo\\_function",source:"@site/docs/reference/moclo_assembly/moclo_transformation/moclo_transform_generator.md",slug:"/reference/moclo_assembly/moclo_transformation/moclo_transform_generator",permalink:"/DJANGO-Assembly-Methods/docs/reference/moclo_assembly/moclo_transformation/moclo_transform_generator",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/moclo_assembly/moclo_transformation/moclo_transform_generator.md",version:"current",sidebar_label:"moclo_assembly.moclo_transformation.moclo_transform_generator",sidebar:"someSidebar",previous:{title:"biobricks_assembly.biobricks10.bbinput",permalink:"/DJANGO-Assembly-Methods/docs/reference/biobricks_assembly/biobricks10/bbinput"},next:{title:"basic_assembly.dna_bot.dnabot_app",permalink:"/DJANGO-Assembly-Methods/docs/reference/basic_assembly/dna_bot/dnabot_app"}},s=[],c={rightToc:s};function m(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},c,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h4",{id:"moclo_function"},"moclo","_","function"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"moclo_function(output_folder: str, construct_path: List[str], part_path: List[str], thermocycle: bool = True, p10_mount: str = 'right', p300_mount: str = 'left', p10_type: str = 'p10_single', p300_type: str = 'p300_multi', well_plate: str = 'biorad_96_wellplate_200ul_pcr', trough: str = 'usascientific_12_reservoir_22ml', reagent_plate: str = 'biorad_96_wellplate_200ul_pcr', agar_plate: str = 'thermofisher_96_wellplate_180ul') -> List[str]\n")),Object(o.b)("p",null,"Main function, creates scripts and metainformation\nCan take specific args or just **labware_dict for all labware"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output_folder")," - the full file path of the intended output folder\nfor files generated"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"construct_path")," - a one element list with the full path of the\nconstruct csv"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"part_path")," - a list of full paths to part csv(s) (one or more)"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"thermocyle")," - True or False, indicating whether the user has\nand would like to use the Opentrons Thermocycler\nsee labware_dict for rest of arguments")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns"),":"),Object(o.b)("p",null,"  List of output paths\nIf there is an exception, the list of output paths will contain\nonly one element = the error path\nOtherwise the list of output paths will contain:\nOT-2 script paths (assembly, transformation),\nmetainformation (assembly, transformation, agar plate)"),Object(o.b)("h4",{id:"generate_plate_maps"},"generate","_","plate","_","maps"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_plate_maps(filename: str) -> Dict[str, List[List]]\n")),Object(o.b)("p",null,"Generates dictionaries for the part csvs\nArgs: filename = absolute path to part csv\nReturns: dictionary of plate maps with key = name of part csv,\nvalue = list of rows (= list of lists)"),Object(o.b)("h4",{id:"generate_combinations"},"generate","_","combinations"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_combinations(combinations_filename: str) -> List[Dict]\n")),Object(o.b)("p",null,"Generates a list of dictionaries of constructs to be made\nArgs: combinations_filename = absolute path to construct csv file\nReturns: List of construct dictionaries with keys ",'"',"name",'"'," and ",'"',"parts",'"'),Object(o.b)("h4",{id:"check_number_of_combinations"},"check","_","number","_","of","_","combinations"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"check_number_of_combinations(combinations_limit: str, combinations_to_make: List[Dict])\n")),Object(o.b)("p",null,"Ensures that the number of constructs does not exceed the maximum"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"combinations_limit")," - ",'"',"single",'"'," or ",'"',"triplicate",'"'," - if ",'"',"single",'"'," can do\nmax 88 constructs, if ",'"',"triplicate",'"'," does every construct 3 times -\nmax 24 constructs"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"Raises")," - ValueError if there are too many constructs or\ncombinations_limit is not ",'"',"single",'"'," or ",'"',"triplicate",'"')),Object(o.b)("h4",{id:"generate_and_save_output_plate_maps"},"generate","_","and","_","save","_","output","_","plate","_","maps"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_and_save_output_plate_maps(combinations_to_make: List[Dict], combinations_limit: str, output_folder_path: str) -> Tuple[str, str]\n")),Object(o.b)("p",null,"Saves the mapping of the agar plate for use in transformation."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("p",null,"  combinations_to_make = list of construct dictionaries\ncombinations_limit = ",'"',"single",'"'," or ",'"',"triplicate",'"',"\noutput_folder_path = where to save mapping"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triplicate")," - whether ","'","single","'"," (triplicate = False) or ","'","triplicate","'","\n(triplicate = True) is selected"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output_filename")," - the absolute path to the agar plate csv")),Object(o.b)("h4",{id:"create_metainformation"},"create","_","metainformation"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_metainformation(output_path: str, dna_plate_map_dict: Dict[str, List[List]], combinations_to_make: List[Dict], labware_dict: Dict[str, str], thermocycle: bool, triplicate: str) -> Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame, pd.DataFrame]\n")),Object(o.b)("p",null,"Returns detailed metainformation and saves in a csv.\nIncludes a parts dataframe, a combinations (constructs)\ndataframe, a reagents dataframe, and a master mix dataframe."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output_path")," - the full path of the output folder"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"dna_plate_map_dict")," - the dictionary of parts"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"combinations_to_make")," - the list of dictionaries of\nconstructs"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"labware_dict")," - the dictionary of labware chosen"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"thermocyle")," - whether the thermocycler module is used"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triplicate")," - whether ","'","single","'"," (triplicate = False) or ","'","triplicate","'","\n(triplicate = True) is selected")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"parts_df")," - dataframe of parts"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"combinations_df")," - dataframe of constructs"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"mm_df")," - master mix dataframe, contains information on all of the\nmaster mixes needed (different master mix needed for different\nnumber of parts per construct)"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"reagents_df")," - reagents dataframe, contains information on all of the\nreagents, does not include master mix but DOES include reagents to\ngo into master mixes")),Object(o.b)("h4",{id:"create_parts_df"},"create","_","parts","_","df"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_parts_df(dna_plate_map_dict: Dict[str, List[List]]) -> pd.DataFrame\n")),Object(o.b)("p",null,"Returns a dataframe of parts and delegates wells.\nTakes in the dictionary of parts."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"dna_plate_map_dict")," - dictionary with keys = plate names, values =\nlist of rows = list of list of parts")),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"parts_df")," - dataframe of parts with dummy ","'","0","'"," for combinations col")),Object(o.b)("h4",{id:"create_mm_df"},"create","_","mm","_","df"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_mm_df(combinations_df: pd.DataFrame) -> pd.DataFrame\n")),Object(o.b)("p",null,"Creates a master mix dataframe and delegates wells.\nDifferent master mixes must be created depending on\nthe number of parts per construct.\nArgs: combinations_df = dataframe of constructs\nReturns: dataframe of master mixes with wells and volumes\nof different reagents required"),Object(o.b)("h4",{id:"create_reagents_df"},"create","_","reagents","_","df"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_reagents_df(mm_df: pd.DataFrame) -> pd.DataFrame\n")),Object(o.b)("p",null,"Creates a dataframe of reagents used to make master mixes.\nMore than one buffer well may be required, and water is\nheld on a separate plate.\nAlso indicates which master mix wells the reagent is\ntransferred to.\nArgs: master mix dataframe\nReturns: dataframe of reagents used in master mix + water"),Object(o.b)("h4",{id:"get_mm_dicts"},"get","_","mm","_","dicts"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"get_mm_dicts(mm_df: pd.DataFrame, reagents_df: pd.DataFrame) -> Tuple[Dict[str, List[Tuple[str, str, str]]], Dict]\n")),Object(o.b)("p",null,"Master mix dictionary purely for use in the assembly script.\nProvides instructions on tranfers."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("p",null,"  mm_df = dataframe of master mix, gives wells and diff vol needed\nreagents_df = dataframe of reagents to be used in master mix and\nother parts of assembly"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Returns"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"reagent_to_mm_dict")," - dictionary directing where to transfer each\nreagent to to make master mixes, key = reagent well, value =\nlist of tuples of reagent plate (different for water and other\nreagents), master mix well, and volume to be transferred\nmm_dict_list = mm_df rows stored as dictionaries in list")),Object(o.b)("h4",{id:"index_to_well_name"},"index","_","to","_","well","_","name"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"index_to_well_name(no: int) -> str\n")),Object(o.b)("p",null,"Converts well from number format to letter format\nArgs: well in number format e.g. 0\nReturns: well in letter format e.g. ","'","A1","'"),Object(o.b)("h4",{id:"create_transform_metainformation"},"create","_","transform","_","metainformation"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_transform_metainformation(output_path: str, labware_dict: Dict[str, str], triplicate: str, multi: bool)\n")),Object(o.b)("p",null,"Saves transform metainformation and labware informaiton.\nSOC used in two steps: adding soc (150 uL) and dilution (45 uL)\ntimes by 96 as reaction plate has 96 wells\nAdd 300 (150",Object(o.b)("em",{parentName:"p"},"2) and 90 (45"),"2) as dead vols\nAgar plate positions in agar plate csv"),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output_path")," - absolute path to transformation metainformation file"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"labware_dict")," - dictionary of labware to be used"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triplicate")," - whether ","'","single","'"," (triplicate = False) or ","'","triplicate","'","\n(triplicate = True) is selected"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"multi")," - whether an 8 channel (multi = True) or single channel\n(mutli = False) p300 pipette is being used")),Object(o.b)("h4",{id:"create_protocol"},"create","_","protocol"),Object(o.b)("pre",null,Object(o.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"create_protocol(dna_plate_map_dict: Dict[str, List], combinations_to_make: List[Dict], reagent_to_mm_dict: Dict, mm_dict: Dict, assembly_template_path: str, transform_template_path: str, output_folder_path: str, thermocycle: bool, triplicate: str, multi: bool, p10Mount: str, p300Mount: str, p10_type: str, p300_type: str, reaction_plate_type: str, reagent_plate_type: str, trough_type: str, agar_plate_type: str) -> Tuple[str, str]\n")),Object(o.b)("p",null,"Generates the assembly and transformation protocols used by opentrons.\nReturns the paths of the assembly and transform scripts."),Object(o.b)("p",null,Object(o.b)("strong",{parentName:"p"},"Arguments"),":"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"dna_plate_map_dict")," - the dictionary of parts"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"combinations_to_make")," - the list of dictionaries of\nconstructs"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"reagent_to_mm_dict")," - dictionary directing where to transfer each\nreagent to to make master mixes, key = reagent well, value =\nlist of tuples of reagent plate (different for water and other\nreagents), master mix well, and volume to be transferred\nmm_dict_list = mm_df rows stored as dictionaries in list"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"assembly_template_path")," - the absolute path of the assembly template\nscript"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"transform_template_path")," - the absolute path of the transformation\ntemplate script"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"output_folder_path")," - the absolute path to the output folder that\nwill contain the assembly and transformation protocols"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"thermocycle")," - whether or not the Opentrons thermocycler module\nis being used"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"triplicate")," - whether ","'","single","'"," (triplicate = False) or ","'","triplicate","'","\n(triplicate = True) is selected"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"multi")," - whether an 8 channel (multi = True) or single channel\n(mutli = False) p300 pipette is being used"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"p10_mount")," - ",'"',"left",'"'," or ",'"',"right",'"',", the Opentrons pipette mount options"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"p300_mount")," - ",'"',"left",'"'," or ",'"',"right",'"',", the Opentrons pipette mount options"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"p10_type")," - the name of the p10 pipette, e.g. ",'"',"p10_single",'"'),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"p300_type")," - the name of the p300 pipette, e.g. ",'"',"p300_single",'"'),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"reaction_plate_type")," - the name of the well plate type used as the\nsource and construct plate"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"reagent_plate_type")," - the name of the well plate type used as the\nreagent plate (for master mix and non-water reagents)"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"trough_type")," - the name of the trough type used for water and soc"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("inlineCode",{parentName:"li"},"agar_plate_type")," - the name of the agar plate type used")))}m.isMDXComponent=!0},93:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=r.a.createContext({}),m=function(e){var t=r.a.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},b=function(e){var t=m(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=m(a),u=n,d=b["".concat(i,".").concat(u)]||b[u]||p[u]||o;return a?r.a.createElement(d,l(l({ref:t},c),{},{components:a})):r.a.createElement(d,l({ref:t},c))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=a.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);