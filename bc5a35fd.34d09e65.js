(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{79:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return b}));var r=n(2),a=n(6),l=(n(0),n(93)),s={sidebar_label:"biobricks_assembly.biobricks10.bbinput",title:"biobricks_assembly.biobricks10.bbinput"},i={unversionedId:"reference/biobricks_assembly/biobricks10/bbinput",id:"reference/biobricks_assembly/biobricks10/bbinput",isDocsHomePage:!1,title:"biobricks_assembly.biobricks10.bbinput",description:"biobricks",source:"@site/docs/reference/biobricks_assembly/biobricks10/bbinput.md",slug:"/reference/biobricks_assembly/biobricks10/bbinput",permalink:"/DJANGO-Assembly-Methods/docs/reference/biobricks_assembly/biobricks10/bbinput",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/biobricks_assembly/biobricks10/bbinput.md",version:"current",sidebar_label:"biobricks_assembly.biobricks10.bbinput",sidebar:"someSidebar",next:{title:"moclo_assembly.moclo_transformation.moclo_transform_generator",permalink:"/DJANGO-Assembly-Methods/docs/reference/moclo_assembly/moclo_transformation/moclo_transform_generator"}},o=[],c={rightToc:o};function b(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(l.b)("wrapper",Object(r.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h4",{id:"biobricks"},"biobricks"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"biobricks(output_folder: str, construct_path: List[str], part_path: List[str], thermocycle: bool = True, p10_mount: str = 'right', p300_mount: str = 'left', p10_type: str = 'p10_single', p300_type: str = 'p300_single', well_plate: str = 'biorad_96_wellplate_200ul_pcr', tube_rack: str = 'opentrons_24_tuberack_nest_1.5ml_snapcap', soc_plate: str = 'usascientific_96_wellplate_2.4ml_deep', transformation_plate: str = 'corning_96_wellplate_360ul_flat') -> List[str]\n")),Object(l.b)("p",null,"Main function, creates scripts and metainformation\nCan take specific args or just **labware_dict for all labware"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"output_folder")," - the full file path of the intended output folder\nfor files generated"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"construct_path")," - a one element list with the full path of the\nconstruct csv"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"part_path")," - a list of full paths to part csv(s) (one or more)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"thermocyle")," - True or False, indicating whether the user has\nand would like to use the Opentrons Thermocycler\nsee labware_dict for rest of arguments")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  List of output paths\nIf there is an exception, the list of output paths will contain\nonly one element = the error path\nOtherwise the list of output paths will contain:\nOT-2 script paths (assembly, transformation),\nmetainformation"),Object(l.b)("h4",{id:"get_constructs"},"get","_","constructs"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"get_constructs(path: str) -> Tuple[pd.DataFrame, List[str]]\n")),Object(l.b)("p",null,"Returns construct dataframe from constructs csv\nArgs: path = path of construct csv"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"merged_constructs_list")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"dest_well_list")," - list of wells in construct plate that are used")),Object(l.b)("h4",{id:"process_construct"},"process","_","construct"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"process_construct(construct_entry: List) -> Dict[str, List[str]]\n")),Object(l.b)("p",null,"Returns construct dictionary from row in csv file\nUsed in get_constructs()\nArgs: construct_entry = construct row from csv in list\nReturns: Dictionary of construct info"),Object(l.b)("h4",{id:"get_parts"},"get","_","parts"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"get_parts(paths: List[str], constructs_list: pd.DataFrame) -> pd.DataFrame\n")),Object(l.b)("p",null,"Returns a dataframe of parts from part csv file.\nUses constructs_list to record the number of times the part is used\nin the constructs and the roles it plays."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"paths")," - list of paths to part csvs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - dataframe of constructs")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"merged_parts_list")," - dataframe of parts")),Object(l.b)("h4",{id:"process_part"},"process","_","part"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"process_part(part: List, constructs_list: pd.DataFrame, plate: str) -> Dict[str, List]\n")),Object(l.b)("p",null,"Returns a part dataframe with detailed information.\nUsed in get_parts()"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"part")," - row of part csv file"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - constructs dataframe"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"plate")," - source plate of part")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  Dataframe of individual part"),Object(l.b)("h4",{id:"get_reagents_wells"},"get","_","reagents","_","wells"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"get_reagents_wells(constructs_list: pd.DataFrame, parts: pd.DataFrame) -> Tuple[pd.DataFrame, List[str], pd.DataFrame]\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts")," - dataframe of parts")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  Dataframe with rows as reagent names and cols\nas the reagent well and the volume of the reagent required.\nList of wells used for reagents in reagents tube rack\nMaster mix dataframe giving volumes of each reagent"),Object(l.b)("h4",{id:"get_digests"},"get","_","digests"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"get_digests(constructs_list: pd.DataFrame, parts: pd.DataFrame, reagents: pd.DataFrame) -> Tuple[pd.DataFrame, pd.DataFrame]\n")),Object(l.b)("p",null,"Creates a dataframe of digests, the intermediate step in assembly\nBioBricks constructs."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts")," - dataframe of parts"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagents")," - dataframe of reagents")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  dataframe of digests\nupdated parts dataframe with digest well column"),Object(l.b)("h4",{id:"next_well"},"next","_","well"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"next_well(wells_used: List[str]) -> str\n")),Object(l.b)("p",null,"Finds the next available well from a list of used wells\nfor a 96 well plate"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("p",null,"  List of wells used in 96 well plate"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  Next unused well in 96 well plate"),Object(l.b)("h4",{id:"next_well_reagent"},"next","_","well","_","reagent"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"next_well_reagent(wells_used: List[str]) -> str\n")),Object(l.b)("p",null,"Finds the next available well from a list of used wells\nfor a 24 well plate/tube rack"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("p",null,"  List of wells used in 24 well plate/tube rack"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  Next unused well in 24 well plate/tube rack"),Object(l.b)("h4",{id:"count_part_occurences"},"count","_","part","_","occurences"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"count_part_occurences(constructs_list: pd.DataFrame, part: List) -> Tuple[List[int], List[List[int]]]\n")),Object(l.b)("p",null,"Counts the number of times a part is used in the constructs.\nDifferentiates between upstream uses, downstream uses,\nand plasmid uses: all require different digests."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"part")," - row in part csv file as list")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"counts")," - list where 0th element = upstream counts,\n1st element = downstream counts, 2nd element =\nplasmid counts"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_in_upstream")," - index of constructs a part appears\nin as the upstream part"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_in_downstream")," - index of constructs a part appears\nin as the downstream part"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_in_plasmid")," - index of constructs a part appears\nin as the plasmid part")),Object(l.b)("h4",{id:"create_assembly_dicts"},"create","_","assembly","_","dicts"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"create_assembly_dicts(constructs: pd.DataFrame, parts: pd.DataFrame, digests: pd.DataFrame, reagents: pd.DataFrame) -> Tuple[Dict, Dict, Dict, Dict, Dict]\n")),Object(l.b)("p",null,"Returns assembly dictionaries to be used in the assembly protocol,\ninstructing which transfers need to be made."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts")," - dataframe of parts"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"digests")," - dataframe of digests"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagents")," - dataframe of reagents")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"source_to_digest")," - dictionary with key = source (part) well,\nkey = list of tuples in format (digest well, volume to transfer)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagent_to_digest")," - dictionary with key = reagent well,\nkey = list of tuples in format (digest well, volume to transfer)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"digest_to_construct")," - dictionary with key = digest well,\nkey = list of tuples in format (construct well, volume to transfer)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagent_to_construct")," - dictionary with key = reagent well,\nkey = list of tuples in format (construct well, volume to transfer)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagents_dict")," - dictionary with key = reagent name,\nkey = reagent well")),Object(l.b)("h4",{id:"create_tranformation_dicts"},"create","_","tranformation","_","dicts"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"create_tranformation_dicts(constructs: pd.DataFrame, water_well: str = 'A1', controls_per_cons: bool = False) -> Tuple[Dict[str, List[Tuple[str, int]]], Dict[str, List[Tuple[str, int]]],\n           Dict[str, List[Tuple[str, int]]], Dict[str, List[Tuple[str, int]]],\n           pd.DataFrame]\n")),Object(l.b)("p",null,"Creates transformation dictionaries to be used in the\ntransformation protocol, instructing which transfers need to be made.\nCreates transform_df for metainformation\nCompetent wells + construct wells -",">"," same well for transformation.\nControl wells + water well -",">"," same well for transformation."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Constructs")," - dataframe of constructs"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"water_well")," - well that water is stored in"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"controls_per_cons")," - create three controls per construct if True\ncreate three controls total if False")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"competent_source_to_dest")," - dictionary with key = competent cell\nwell, value = tuple of destination well + transfer vol"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"control_source_to_dest")," - dictionary with key = control cell\nwell, value = tuple of destination well + transfer vol"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"assembly_source_to_dest")," - dictionary with key = construct\nwell, value = tuple of destination well + transfer vol,"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"water_source_to_dest")," - dictionary with key = water\nwell, value = tuple of destination well + transfer vol"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"transform_df")," - dataframe of transformation reactions")),Object(l.b)("h4",{id:"create_assembly_protocol"},"create","_","assembly","_","protocol"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"create_assembly_protocol(template_path: str, output_path: str, source_to_digest: Dict[str, List[Tuple[str, int]]], reagent_to_digest: Dict[str, List[Tuple[str, int]]], digest_to_construct: Dict[str, List[Tuple[str, int]]], reagent_to_construct: Dict[str, List[Tuple[str, int]]], reagents_dict: Dict[str, str], p10_mount: str, p10_type: str, well_plate_type: str, tube_rack_type: str, thermocycle: bool) -> str\n")),Object(l.b)("p",null,"Generates the assembly protocol used by opentrons.\nReturns the path of the assembly script."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"template_path")," - absolute path of the Opentrons script template"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"output_path")," - absolute path of the output folder to save protocol in"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"source_to_digest")," - dictionary of form\nDict[str, List","[Tuple(str, int)]","], dictionary key (string) gives\nsource (part) well to transfer from, the 0th element of each tuple\ngives well to transfer to (digest well in this case), with the 1st\nelement of the tuple giving the volume to transfer."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagent_to_digest")," - dictionary of same form as source_to_digest\n(Dict[str, List","[Tuple(str, int)]","]), instructing transfers from\nreagent wells to digest wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"digest_to_storage")," - dictionary of same form as source_to_digest\n(Dict[str, List","[Tuple(str, int)]","]), instructing transfers from\ndigest wells to storage wells (wells where digest not used in\nconstruct is stored after assembly)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"digest_to_construct")," - dictionary of same form as source_to_digest\n(Dict[str, List","[Tuple(str, int)]","]), instructing transfers from\ndigest wells to construct wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"reagent_to_construct")," - dictionary of same form as source_to_digest\n(Dict[str, List","[Tuple(str, int)]","]), instructing transfers from\nreagent wells to construct wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p10_mount")," - ",'"',"left",'"'," or ",'"',"right",'"',", the Opentrons pipette mount options"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p10_type")," - the name of the p10 pipette, e.g. ",'"',"p10_single",'"'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"well_plate_type")," - the name of the well plate type used as the source\nplate and construct plate"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tube_rack_type")," - the name of the tube rack type used for holding the\nreagents"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"thermocycle")," - True or False, True = run thermocycle module in\nscripts, False = use benchtop thermocycler")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  path of assembly protocol script"),Object(l.b)("h4",{id:"create_transformation_protocol"},"create","_","transformation","_","protocol"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"create_transformation_protocol(template_path: str, output_path: str, competent_source_to_dest: Dict[str, List], control_source_to_dest: Dict[str, List], assembly_source_to_dest: Dict[str, List], water_source_to_dest: Dict[str, List], p10_mount: str, p300_mount: str, p10_type: str, p300_type: str, well_plate_type: str, transformation_plate_type: str, tube_rack_type: str, soc_plate_type: str) -> str\n")),Object(l.b)("p",null,"Generates the transformation protocol used by opentrons."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"template_path")," - absolute path of the Opentrons script template"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"output_path")," - absolute path of the output folder to save protocol in"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"competent_source_to_digest")," - dictionary of form\nDict[str, List","[Tuple(str, int)]","], dictionary key (string) gives\ncompetent cell well to transfer from, the 0th element of each tuple\ngives well to transfer to (transformation well), with the 1st\nelement of the tuple giving the volume to transfer."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"control_source_to_digest")," - dictionary of same form as\ncompetent_source_to_digest (Dict[str, List","[Tuple(str, int)]","]),\ninstructing transfers from control wells to transformation wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"assembly_source_to_digest")," - dictionary of same form as\ncompetent_source_to_digest (Dict[str, List","[Tuple(str, int)]","]),\ninstructing transfers from construct wells to transformation wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"water_source_to_digest")," - dictionary of same form as\ncompetent_source_to_digest (Dict[str, List","[Tuple(str, int)]","]),\ninstructing transfers from water well to transformation wells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p10_mount")," - ",'"',"left",'"'," or ",'"',"right",'"',", the Opentrons pipette mount options"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p300_mount")," - ",'"',"left",'"'," or ",'"',"right",'"',", the Opentrons pipette mount options"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p10_type")," - the name of the p10 pipette, e.g. ",'"',"p10_single",'"'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"p300_type")," - the name of the p300 pipette, e.g. ",'"',"p300_single",'"'),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"well_plate_type")," - the name of the well plate type used as the\nconstruct plate"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"transformation_plate_type")," - the name of the well plate type used as the\ntransformation plate"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"tube_rack_type")," - the name of the tube rack type used to store cells"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"soc_plate_type")," - the name of the plate type used to store soc")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  path of transform protocol script"),Object(l.b)("h4",{id:"dfs_to_csv"},"dfs","_","to","_","csv"),Object(l.b)("pre",null,Object(l.b)("code",Object(r.a)({parentName:"pre"},{className:"language-python"}),"dfs_to_csv(path, index=True, **kw_dfs)\n")),Object(l.b)("p",null,"Generates a csv file defined by path, where kw_dfs are\nwritten one after another with each key acting as a title. If index=True,\ndf indexes are written to the csv file."))}b.isMDXComponent=!0},93:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var r=n(0),a=n.n(r);function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){l(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),b=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=b(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},m=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=b(n),m=r,d=p["".concat(s,".").concat(m)]||p[m]||u[m]||l;return n?a.a.createElement(d,i(i({ref:t},c),{},{components:n})):a.a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,s=new Array(l);s[0]=m;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var c=2;c<l;c++)s[c]=n[c];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);