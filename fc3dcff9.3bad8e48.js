(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{91:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return i})),a.d(t,"rightToc",(function(){return c})),a.d(t,"default",(function(){return p}));var n=a(2),r=a(6),l=(a(0),a(96)),s={sidebar_label:"basic_assembly.dna_bot.dnabot_app",title:"basic_assembly.dna_bot.dnabot_app"},i={unversionedId:"reference/basic_assembly/dna_bot/dnabot_app",id:"reference/basic_assembly/dna_bot/dnabot_app",isDocsHomePage:!1,title:"basic_assembly.dna_bot.dnabot_app",description:"dnabot",source:"@site/docs/reference/basic_assembly/dna_bot/dnabot_app.md",slug:"/reference/basic_assembly/dna_bot/dnabot_app",permalink:"/DJANGO-Assembly-Methods/docs/reference/basic_assembly/dna_bot/dnabot_app",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/reference/basic_assembly/dna_bot/dnabot_app.md",version:"current",sidebar_label:"basic_assembly.dna_bot.dnabot_app",sidebar:"someSidebar",previous:{title:"moclo_assembly.moclo_transformation.moclo_transform_generator",permalink:"/DJANGO-Assembly-Methods/docs/reference/moclo_assembly/moclo_transformation/moclo_transform_generator"},next:{title:"sbol_parser_api.sbol_parser_api",permalink:"/DJANGO-Assembly-Methods/docs/reference/sbol_parser_api/sbol_parser_api"}},c=[],o={rightToc:c};function p(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(l.b)("wrapper",Object(n.a)({},o,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("h4",{id:"dnabot"},"dnabot"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"dnabot(output_folder: str, ethanol_well_for_stage_2: str, deep_well_plate_stage_4: str, input_construct_path: List[str], output_sources_paths: List[str], p10_mount: str = 'right', p300_mount: str = 'left', p10_type: str = 'p10_single', p300_type: str = 'p300_multi', well_plate: str = 'biorad_96_wellplate_200ul_pcr', reagent_plate: str = 'usascientific_12_reservoir_22ml', mag_plate: str = 'biorad_96_wellplate_200ul_pcr', tube_rack: str = 'opentrons_24_tuberack_nest_1.5ml_snapcap', aluminum_block: str = 'opentrons_96_aluminumblock_biorad_wellplate_200ul', bead_container: str = 'usascientific_96_wellplate_2.4ml_deep', soc_plate: str = 'usascientific_96_wellplate_2.4ml_deep', agar_plate: str = 'thermofisher_96_wellplate_180ul') -> List[str]\n")),Object(l.b)("p",null,"Main function, creates scripts and metainformation\nCan take specific args or just **labware_dict for all labware"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"output_folder")," - the full file path of the intended output folder\nfor files generated\nethanol_well_for_stage_2 = ethanol well in letter format e.g.\n","'","A1","'"," to be used in purification\ndeep_well_plate_stage_4 = soc well to be used in transformation\nplease only enter wells from ","'","A1","'"," to ","'","A12","'"," as this is a trough"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"construct_path")," - a one element list with the full path of the\nconstruct csv"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"part_path")," - a list of full paths to part csv(s) (one or more)\nsee labware_dict for rest of arguments")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  List of output paths\nIf there is an exception, the list of output paths will contain\nonly one element = the error path\nOtherwise the list of output paths will contain:\nOT-2 script paths (clip, thermocycle, purification, assembly,\ntransformation), metainformation (clip run info, final assembly\ndict, wells - ethanol well and soc well)"),Object(l.b)("h4",{id:"generate_constructs_list"},"generate","_","constructs","_","list"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_constructs_list(path: str) -> List[pd.DataFrame]\n")),Object(l.b)("p",null,"Generates a list of dataframes corresponding to each construct. Each\ndataframe lists components of the CLIP reactions required.\nArgs: path = the absolute path of the constructs file\nReturns: List of dataframes, in which each dataframe = construct"),Object(l.b)("h4",{id:"generate_clips_df"},"generate","_","clips","_","df"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_clips_df(constructs_list: List[pd.DataFrame]) -> pd.DataFrame\n")),Object(l.b)("p",null,"Generates a dataframe containing information about all the unique clip\nreactions required to synthesise the constructs in constructs_list.\nArgs: list of constructs stored as dataframes\nReturns: dataframe of all constructs"),Object(l.b)("h4",{id:"generate_sources_dict"},"generate","_","sources","_","dict"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_sources_dict(paths: List[str]) -> Tuple[Dict[str, Tuple], pd.DataFrame]\n")),Object(l.b)("p",null,"Imports csvs files containing a series of parts/linkers with\ncorresponding information into a dictionary where the key corresponds with\npart/linker and the value contains a tuple of corresponding information."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"paths")," ",Object(l.b)("em",{parentName:"li"},"list")," - list of strings each corresponding to a path for a\nsources csv file.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"sources_dict")," - a dictionary with keys = part names, values = tuple of\nvalues - either well, concentration, plate or well, plate depending on\nwhether concentration is provided for the part"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts_df")," - dataframe of parts with cols = concentration, name, well,\nplate")),Object(l.b)("h4",{id:"fill_parts_df"},"fill","_","parts","_","df"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"fill_parts_df(clips_df: pd.DataFrame, parts_df_temp: pd.DataFrame) -> pd.DataFrame\n")),Object(l.b)("p",null,"Fill dataframe of parts with metainformation to be stored in csv.\nWill add final assembly well in generate_final_assembly_dict()"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"clips_df")," - the dataframe of clips created as intermediate steps\nbefore assembly"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts_df_temp")," - the previous parts_df dataframe to be expanded on")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  parts_df, with new columns of ","'","clip_well","'",", ","'","mag_well","'",", ","'","total_vol","'",",\n","'","vol_per_clip","'",", and ","'","number","'"),Object(l.b)("h4",{id:"generate_clips_dict"},"generate","_","clips","_","dict"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_clips_dict(clips_df: pd.DataFrame, sources_dict: Dict[str, Tuple], parts_df: pd.DataFrame) -> Dict[str, List]\n")),Object(l.b)("p",null,"Using clips_df and sources_dict, returns a clips_dict which acts as the\nsole variable for the opentrons script ",'"',"clip.ot2.py",'"',"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"clips_df")," - dataframe of clip reactions"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"sources_dict")," - dictionary of parts with csv values as keys"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts_df")," - dataframe of parts")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"clips_dict")," - dictionary to be used by 1_clip.ot2.py")),Object(l.b)("h4",{id:"generate_final_assembly_dict"},"generate","_","final","_","assembly","_","dict"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_final_assembly_dict(constructs_list: pd.DataFrame, clips_df: pd.DataFrame, parts_df: pd.DataFrame) -> Tuple[Dict[str, List[str]], pd.DataFrame, pd.DataFrame]\n")),Object(l.b)("p",null,"Using constructs_list and clips_df, returns a dictionary of final\nassemblies with keys defining destination plate well positions and\nvalues indicating which clip reaction wells are used."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"constructs_list")," - list of constructs, constructs = dataframes"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"clips_df")," - dataframe of clip reactions"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parts_df")," - dataframe of parts")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  dictionary of final assemblies with keys = destination plate,\nvalues = list of clip wells\nclips_df and parts_df updated with construct well column"),Object(l.b)("h4",{id:"calculate_final_assembly_tipracks"},"calculate","_","final","_","assembly","_","tipracks"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"calculate_final_assembly_tipracks(final_assembly_dict: Dict[str, List[str]]) -> int\n")),Object(l.b)("p",null,"Calculates the number of final assembly tipracks required ensuring\nno more than MAX_FINAL_ASSEMBLY_TIPRACKS are used.\nArgs: final_assembly_dict = dictionary with keys = final assembly\nwells, values = list of clip wells\nReturns: number of tipracks needed in final assembly\n(3_assembly.ot2.py)\nRaises: ValueError if final assembly tiprack number ",">"," tiprack slots"),Object(l.b)("h4",{id:"generate_spotting_tuples"},"generate","_","spotting","_","tuples"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_spotting_tuples(constructs_list: List[pd.DataFrame], spotting_vols_dict: Dict[int, int]) -> List[Tuple]\n")),Object(l.b)("p",null,"Using constructs_list, generates a spotting tuple\n(Refer to ","'","transformation_spotting_template.py","'",") for every column of\nconstructs, assuming the 1st construct is located in well A1 and wells\nincrease linearly. Target wells locations are equivalent to construct well\nlocations and spotting volumes are defined by spotting_vols_dict."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"spotting_vols_dict")," ",Object(l.b)("em",{parentName:"li"},"dict")," - Part number defined by keys, spotting\nvolumes defined by corresponding value.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  List of three tuples as instructions for transformation script"),Object(l.b)("h4",{id:"generate_ot2_script"},"generate","_","ot2","_","script"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_ot2_script(parent_dir, ot2_script_path, template_path, **kwargs)\n")),Object(l.b)("p",null,"Generates an ot2 script named ","'","ot2_script_path","'",", where kwargs are\nwritten as global variables at the top of the script. For each kwarg, the\nkeyword defines the variable name while the value defines the name of the\nvariable. The remainder of template file is subsequently written below."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"parent_dir")," ",Object(l.b)("em",{parentName:"li"},"str")," - output folder dir"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"ot2_script_path")," ",Object(l.b)("em",{parentName:"li"},"str")," - where the script should be saved, relative to\nthe parent_dir"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"template_path")," ",Object(l.b)("em",{parentName:"li"},"str")," - where the template script can be found")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  absolute path of script (str)"),Object(l.b)("h4",{id:"generate_master_mix_df"},"generate","_","master","_","mix","_","df"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_master_mix_df(clip_number: int) -> pd.DataFrame\n")),Object(l.b)("p",null,"Generates a dataframe detailing the components required in the clip\nreaction master mix.\nArgs: Number of clips needed in total\nReturns: master mix dataframe containing reagents + volumes"),Object(l.b)("h4",{id:"generate_sources_paths_df"},"generate","_","sources","_","paths","_","df"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"generate_sources_paths_df(paths: List[str], deck_positions: List[str]) -> pd.DataFrame\n")),Object(l.b)("p",null,"Generates a dataframe detailing source plate information."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments"),":"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"paths")," ",Object(l.b)("em",{parentName:"li"},"list")," - list of strings specifying paths to source plates."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"deck_positions")," ",Object(l.b)("em",{parentName:"li"},"list")," - list of strings specifying candidate deck\npositions.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns"),":"),Object(l.b)("p",null,"  Dataframe containing source plate information"),Object(l.b)("h4",{id:"dfs_to_csv"},"dfs","_","to","_","csv"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"dfs_to_csv(path, index=True, **kw_dfs)\n")),Object(l.b)("p",null,"Generates a csv file defined by path, where kw_dfs are\nwritten one after another with each key acting as a title. If index=True,\ndf indexes are written to the csv file."),Object(l.b)("h4",{id:"handle_2_columns"},"handle","_","2","_","columns"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"handle_2_columns(datalist)\n")),Object(l.b)("p",null,"This function has the intent of changing:\n(","'","A8","'",", ","'","2","'",") =",">"," (","'","A8","'",", ","'","'",", ","'","2","'",")\n(","'","A8","'",", ","'","'",", ","'","2","'",") =",">"," (","'","A8","'",", ","'","'",", ","'","2","'",")\n","[(","'","E2","'",", ","'","5","'",")]"," =",">"," ","[(","'","E2","'",", ","'","'",", ","'","5","'",")][(&#x27;G1&#x27;, &#x27;&#x27;, &#x27;5&#x27;)]"," =",">"," ","[(","'","G1","'",", ","'","'",", ","'","5","'",")]","\nwith the purpose of handling 2 column csv part file inputs,\nas at times when 2 column csv files are input it creates tuples\nof length 2 instead of 3"),Object(l.b)("h4",{id:"final_well"},"final","_","well"),Object(l.b)("pre",null,Object(l.b)("code",Object(n.a)({parentName:"pre"},{className:"language-python"}),"final_well(sample_number: int) -> str\n")),Object(l.b)("p",null,"Determines well containing the final sample from sample number.\nArgs: sample_number = integer, e.g. 0 = well index\nReturns: well in string form, e.g. ","'","A1","'"," if sample_number = 0"))}p.isMDXComponent=!0},96:function(e,t,a){"use strict";a.d(t,"a",(function(){return b})),a.d(t,"b",(function(){return d}));var n=a(0),r=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),p=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},b=function(e){var t=p(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,s=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),b=p(a),m=n,d=b["".concat(s,".").concat(m)]||b[m]||u[m]||l;return a?r.a.createElement(d,i(i({ref:t},o),{},{components:a})):r.a.createElement(d,i({ref:t},o))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,s=new Array(l);s[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var o=2;o<l;o++)s[o]=a[o];return r.a.createElement.apply(null,s)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);